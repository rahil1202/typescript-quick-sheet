
# **Topic 3: Object & Function Types**

Object and function types are the **backbone of TypeScript applications**. Understanding how to model data, define strict contracts, and leverage functions with type safety is essential for large-scale projects.

---

## **1️⃣ Core Concepts**

### 1. Interfaces vs Type Aliases

* **Interface:** Best for **object shapes**, extendable, supports declaration merging.
* **Type Alias:** More flexible, can represent **primitives, unions, tuples, intersections**, but cannot merge.

```ts
interface User {
  id: number;
  name: string;
}

type UserType = {
  id: number;
  name: string;
};
```

**Extend/Inheritance Example**

```ts
interface Employee extends User {
  role: string;
}

type EmployeeType = UserType & { role: string };
```

---

### 2. Optional & Readonly Properties

* Optional properties allow partial objects.
* Readonly prevents modification after initialization.

```ts
interface Config {
  readonly host: string;
  port?: number;
}

const cfg: Config = { host: "localhost" };
// cfg.host = "127.0.0.1"; // ❌ Error
```

---

### 3. Function Types

* **Explicit Function Type**

```ts
let add: (a: number, b: number) => number;
add = (x, y) => x + y;
```

* **Interface for Function**

```ts
interface MathOperation {
  (x: number, y: number): number;
}

const multiply: MathOperation = (a, b) => a * b;
```

---

### 4. Function Overloading

```ts
function combine(a: string, b: string): string;
function combine(a: number, b: number): number;
function combine(a: any, b: any) {
  return a + b;
}

combine(1, 2);      // 3
combine("a", "b");  // "ab"
```

---

### 5. Index Signatures

* Allow objects with dynamic keys.

```ts
interface ErrorMessages {
  [key: string]: string;
}

const errors: ErrorMessages = { email: "Invalid email", name: "Required" };
```

---

### 6. Callable & Hybrid Types

* Function objects with extra properties.

```ts
interface Counter {
  (start: number): string;
  interval: number;
  reset(): void;
}

function getCounter(): Counter {
  let counter = (start: number) => `Count: ${start}` as string;
  counter.interval = 10;
  counter.reset = () => { counter.interval = 0; };
  return counter as Counter;
}

const c = getCounter();
console.log(c(5)); // Count: 5
```

---

### 7. Type Narrowing & Type Guards

* Narrow types for safe operations.

```ts
function printId(id: number | string) {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}
```

* Custom type guards:

```ts
interface Fish { swim(): void; }
interface Bird { fly(): void; }

function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}
```

---

## **2️⃣ Real-World Production Use Cases (15 examples with code)**

1. **Typed API Response**

```ts
interface UserResponse { id: number; name: string; email: string; }
```

2. **Form Inputs**

```ts
interface FormField { value: string; error?: string; }
```

3. **Redux Action Objects**

```ts
interface Action { type: string; payload?: any; }
```

4. **Component Props in React**

```ts
interface ButtonProps { label: string; onClick(): void; disabled?: boolean; }
```

5. **Dynamic Error Messages**

```ts
interface Errors { [field: string]: string; }
```

6. **Function Overloads for API Calls**

```ts
function fetchData(id: number): User;
function fetchData(url: string): any;
```

7. **Hybrid Objects for Counters / Timers**

```ts
interface Timer { (start: number): string; reset(): void; interval: number; }
```

8. **Optional Configurations**

```ts
interface Config { port?: number; host?: string; }
```

9. **Typed Event Handlers**

```ts
interface ClickEvent { targetId: string; x: number; y: number; }
```

10. **Utility Functions**

```ts
type Mapper<T, U> = (item: T) => U;
const mapUserNames: Mapper<User, string> = user => user.name;
```

11. **Polymorphic Components**

```ts
interface BoxProps<T extends React.ElementType> { as?: T; children?: React.ReactNode; }
```

12. **Error Handling Objects**

```ts
interface ErrorResponse { code: number; message: string; }
```

13. **Database Models**

```ts
interface UserModel { id: number; name: string; createdAt: Date; }
```

14. **API Query Params**

```ts
interface QueryParams { [key: string]: string | number; }
```

15. **Logging Functions**

```ts
interface Logger { (msg: string): void; level: "info" | "warn" | "error"; }
```

---

### ✅ **Summary of Topic 3**

* **Interfaces & type aliases** are the foundation of object typing.
* **Functions** can be strictly typed, overloaded, and hybrid.
* **Index signatures** and **type guards** enhance safety and flexibility.
* Real-world usage is everywhere: **API responses, Redux actions, forms, component props, logging, timers**, etc.


Do you want me to generate it now?
