
# **Topic 4: Classes & OOP in TypeScript**

TypeScript enhances JavaScript classes with **type annotations, access modifiers, generics, and abstract classes**. Understanding these is key for building **scalable, maintainable applications**.

---

## **1️⃣ Core Concepts**

### 1. Classes with Properties & Methods

```ts
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet(): string {
    return `Hello, my name is ${this.name}`;
  }
}

const p1 = new Person("Rahil", 25);
console.log(p1.greet());
```

---

### 2. Access Modifiers

* **public** (default): accessible anywhere
* **private**: accessible only inside class
* **protected**: accessible in class & subclasses
* **readonly**: cannot be modified after initialization

```ts
class Employee {
  public name: string;
  private salary: number;
  protected department: string;
  readonly id: number;

  constructor(id: number, name: string, salary: number, department: string) {
    this.id = id;
    this.name = name;
    this.salary = salary;
    this.department = department;
  }

  getSalary(): number {
    return this.salary;
  }
}
```

---

### 3. Inheritance & `super`

```ts
class Manager extends Employee {
  constructor(id: number, name: string, salary: number, department: string) {
    super(id, name, salary, department);
  }

  changeDepartment(newDept: string) {
    this.department = newDept; // protected accessible
  }
}
```

---

### 4. Abstract Classes

* Cannot be instantiated
* Can enforce method implementation in subclasses

```ts
abstract class Shape {
  abstract area(): number;

  printArea(): void {
    console.log(`Area is ${this.area()}`);
  }
}

class Circle extends Shape {
  constructor(public radius: number) { super(); }

  area(): number { return Math.PI * this.radius ** 2; }
}
```

---

### 5. Static Properties & Methods

* Belong to the class, not instances

```ts
class Utils {
  static PI = 3.14;

  static calcCircleArea(radius: number): number {
    return Utils.PI * radius ** 2;
  }
}

console.log(Utils.calcCircleArea(5));
```

---

### 6. Generics with Classes

* Generic classes allow reusable and type-safe structures

```ts
class DataStore<T> {
  private data: T[] = [];

  add(item: T) { this.data.push(item); }
  getAll(): T[] { return this.data; }
}

const numberStore = new DataStore<number>();
numberStore.add(10);
numberStore.add(20);
console.log(numberStore.getAll());
```

---

### 7. Getters & Setters

```ts
class Employee2 {
  private _salary: number;

  constructor(salary: number) { this._salary = salary; }

  get salary(): number { return this._salary; }
  set salary(value: number) {
    if (value < 0) throw new Error("Salary cannot be negative");
    this._salary = value;
  }
}
```

---

## **2️⃣ Real-World Production Examples (10+)**

1. **User Model Class**

```ts
class User { constructor(public id: number, public name: string) {} }
```

2. **Database Entity with ID & Timestamps**

```ts
class BaseEntity {
  readonly createdAt: Date = new Date();
  readonly id: string = crypto.randomUUID();
}
```

3. **Service Class for API Calls**

```ts
class ApiService<T> {
  constructor(private endpoint: string) {}
  fetchAll(): Promise<T[]> { return fetch(this.endpoint).then(r => r.json()); }
}
```

4. **Logger Utility**

```ts
class Logger {
  static log(msg: string) { console.log(`[LOG]: ${msg}`); }
}
```

5. **State Management Store**

```ts
class Store<T> {
  private state: T;
  constructor(initial: T) { this.state = initial; }
  setState(newState: T) { this.state = newState; }
  getState(): T { return this.state; }
}
```

6. **Form Field Class**

```ts
class FormField<T> {
  value: T;
  constructor(initial: T) { this.value = initial; }
  validate(): boolean { return !!this.value; }
}
```

7. **Singleton Pattern**

```ts
class Config {
  private static instance: Config;
  private constructor(public settings: any) {}
  static getInstance(): Config { return Config.instance ??= new Config({}); }
}
```

8. **Abstract Notification System**

```ts
abstract class Notification { abstract send(): void; }
class EmailNotification extends Notification {
  send() { console.log("Sending email..."); }
}
```

9. **Event Emitter Class**

```ts
type Listener = (...args: any[]) => void;
class EventEmitter {
  private listeners: Record<string, Listener[]> = {};
  on(event: string, listener: Listener) { this.listeners[event] = this.listeners[event] ?? []; this.listeners[event].push(listener); }
  emit(event: string, ...args: any[]) { this.listeners[event]?.forEach(l => l(...args)); }
}
```

10. **Generic Data Repository**

```ts
class Repository<T> {
  private items: T[] = [];
  add(item: T) { this.items.push(item); }
  getAll(): T[] { return this.items; }
}
```

11. **Access Control Class**

```ts
class RoleManager {
  constructor(private roles: string[]) {}
  hasRole(role: string) { return this.roles.includes(role); }
}
```

12. **Task Scheduler Class**

```ts
class Scheduler {
  schedule(task: () => void, delay: number) { setTimeout(task, delay); }
}
```

---

### ✅ **Summary of Topic 4**

* Classes in TypeScript combine **OOP principles** with **type safety**.
* **Access modifiers, abstract classes, static methods, generics, getters/setters** are widely used in real-world projects.
* Use cases: **Models, Repositories, Services, State Management, Event Emitters, Configs, Notifications, Logging, Form Handling**.

---

