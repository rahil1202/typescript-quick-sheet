
# **50+ Advanced TypeScript Interview Questions with Answers & Follow-ups**

---

## **Level: Advanced / Senior**

### **1. What is the difference between `type` and `interface` in TypeScript?**

**Answer:**

* `interface` is **extendable**, supports declaration merging, better for objects and class contracts.
* `type` can define **primitives, unions, intersections, tuples**, and is not mergeable.

**Follow-up:** Can a `type` extend an `interface`?
**Answer:** Yes, using intersection types:

```ts
interface User { name: string; }
type Employee = User & { id: number; }
```

---

### **2. Explain utility types like `Partial<T>`, `Pick<T,K>` and give a real use case.**

**Answer:**

* `Partial<T>` makes all properties optional.
* `Pick<T, K>` selects specific properties from a type.

**Use case:** Updating a subset of user properties in an API request.

```ts
interface User { id: number; name: string; email: string; }
const update: Partial<User> = { email: "new@mail.com" };
```

**Follow-up:** How would you enforce some fields to always exist while others are optional?
**Answer:** Combine `Required` & `Partial`:

```ts
type UpdateUser = Partial<User> & { id: number };
```

---

### **3. What are type guards and how do you implement them?**

**Answer:**
Type guards are **runtime checks** to narrow types safely. Examples: `typeof`, `instanceof`, or custom guards.

**Example:**

```ts
function isString(value: any): value is string { return typeof value === "string"; }
```

**Follow-up:** Why use `value is string` syntax?
**Answer:** It informs TypeScript that **after this check**, `value` is guaranteed to be of that type.

---

### **4. Explain `unknown` vs `any`.**

**Answer:**

* `any` disables type checking completely.
* `unknown` is safer; you must **narrow or assert** the type before use.

**Follow-up:** Why prefer `unknown` over `any`?
**Answer:** It prevents runtime errors by enforcing explicit type checks.

---

### **5. How does TypeScript implement structural typing?**

**Answer:**

* Type compatibility is **based on shape**, not name.
* Example:

```ts
interface User { name: string; }
const u = { name: "Rahil", age: 25 };
const user: User = u; // ✅ works because shape matches
```

**Follow-up:** Can extra properties cause errors?
**Answer:** **Yes** when assigning **object literals directly**. TypeScript uses **excess property checks** in this case.

---

### **6. Explain intersection vs union types with an example.**

**Answer:**

* Intersection `&` combines multiple types.
* Union `|` allows **one of multiple types**.

```ts
type A = { x: number };
type B = { y: string };
type C = A & B; // {x: number; y: string}
type D = A | B; // {x:number} OR {y:string}
```

**Follow-up:** Can unions and intersections be combined?
**Answer:** Yes, e.g., `(A | B) & C`.

---

### **7. How do mapped types work? Give an example.**

**Answer:**
Mapped types transform keys of an object type.

```ts
type Readonly<T> = { readonly [K in keyof T]: T[K] };
type User = { id: number; name: string };
type ReadonlyUser = Readonly<User>; // {readonly id:number; readonly name:string}
```

**Follow-up:** Can mapped types be combined with `as` keyword?
**Answer:** Yes, to **remap keys** or create suffixes/prefixes.

---

### **8. Explain conditional types with an example.**

**Answer:**
Conditional types allow **type selection based on a condition**.

```ts
type IsString<T> = T extends string ? true : false;
type A = IsString<"hello">; // true
type B = IsString<123>; // false
```

**Follow-up:** Can you make a generic `DeepPartial<T>` using conditional types?
**Answer:**

```ts
type DeepPartial<T> = { [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K] };
```

---

### **9. What are literal types and why are they used?**

**Answer:**
Literal types restrict a variable to **exact values**.

```ts
type Direction = "up" | "down";
let dir: Direction;
dir = "up"; // ✅
```

**Follow-up:** Why prefer literal types over enums?
**Answer:** Smaller bundle size, tree-shakable, simple unions often replace enums.

---

### **10. Explain TypeScript decorators and their use cases.**

**Answer:**
Decorators are **annotations on classes, methods, properties** for **runtime behavior modification**.
**Use case:** Logging, DI (NestJS), ORM (TypeORM), authorization.

**Follow-up:** Difference between **class decorator** and **method decorator**?
**Answer:** Class decorator wraps constructor; method decorator wraps method descriptor.

---

### **11. How does TypeScript handle enums?**

**Answer:**

* Numeric enums: auto-incremented numbers.
* String enums: fixed strings.

```ts
enum Roles { Admin, User, Guest }
enum Direction { Up = "UP", Down = "DOWN" }
```

**Follow-up:** How can enums affect bundle size?
**Answer:** Numeric enums generate **JS objects**, string enums are tree-shakable but still create objects.

---

### **12. Explain `keyof` and indexed access types.**

```ts
interface User { id: number; name: string; email: string }
type UserKeys = keyof User; // "id" | "name" | "email"
type NameType = User["name"]; // string
```

**Follow-up:** How can `keyof` be used in generics?
**Answer:** To enforce **valid keys in functions**:

```ts
function getValue<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; }
```

---

### **13. What are Type Assertions and when to use them?**

**Answer:**
Type assertions tell TS to **treat a variable as a specific type**.

```ts
const input = document.getElementById("id") as HTMLInputElement;
```

**Follow-up:** Difference between `as` and `<Type>` syntax?
**Answer:** `as` is **safe in TSX/React**, `<Type>` can cause conflicts in JSX.

---

### **14. Explain `never` type and use cases.**

**Answer:**

* `never` represents values **that never occur** (functions that throw or infinite loops).

```ts
function throwError(msg: string): never { throw new Error(msg); }
```

**Follow-up:** How is `never` used for exhaustive checks?
**Answer:** In `switch` statements to ensure **all union cases are handled**.

---

### **15. How do you implement a type-safe API response in TypeScript?**

**Answer:**

```ts
interface ApiResponse<T> { data?: T; error?: string; }
const res: ApiResponse<User> = { data: { id: 1, name: "Rahil" } };
```

**Follow-up:** How can generics ensure **response type consistency**?
**Answer:** By parameterizing `T` with the expected object type, TS enforces type safety.

---

### **16. Explain tuple types and readonly tuples.**

```ts
let point: [number, number] = [0, 0];
const readonlyPoint: readonly [number, number] = [1, 2];
// readonlyPoint[0] = 5; ❌
```

**Follow-up:** How are tuples different from arrays?
**Answer:** Tuples have **fixed length and types per index**, arrays are uniform.

---

### **17. How do TypeScript generics improve code reusability?**

**Answer:** Generics let functions/classes work with **multiple types** while maintaining type safety.

```ts
function identity<T>(value: T): T { return value; }
```

**Follow-up:** Give a real-world example in React or API services.
**Answer:** Generic `DataStore<T>` class, or `ApiService<T>` for typed responses.

---

### **18. What is the difference between `unknown[]` and `any[]`?**

**Answer:**

* `any[]` disables type checks.
* `unknown[]` requires **type narrowing** before usage.

**Follow-up:** Which one is safer for library code?
**Answer:** `unknown[]` because it enforces **runtime checks**.

---

### **19. Explain `Partial`, `Required`, `Readonly`, `Pick`, `Omit` in practice.**

* `Partial<User>` → optional fields
* `Required<User>` → all required
* `Readonly<User>` → immutable
* `Pick<User, "id" | "name">` → subset
* `Omit<User, "email">` → exclude field

**Follow-up:** Can you combine multiple utility types?
**Answer:** Yes, e.g., `Readonly<Partial<User>>`.

---

### **20. What are conditional mapped types and give an example?**

```ts
type OptionsFlags<Type> = { [Property in keyof Type]: boolean };
interface Features { darkMode: () => void; newUI: () => void; }
type FeatureFlags = OptionsFlags<Features>; // { darkMode:boolean; newUI:boolean; }
```

**Follow-up:** How can this be used in **forms or feature toggles**?
**Answer:** Automatically map **form fields or features** to booleans for validation or flags.

---

### **21. Explain keyof, typeof, and indexed access together.**

```ts
const user = { id: 1, name: "Rahil" };
type UserKeys = keyof typeof user; // "id" | "name"
```

**Follow-up:** How does it help with **dynamic key-based access**?
**Answer:** You can enforce **valid property names at compile time**.

---

### **22. How does TypeScript enforce strict null checks?**

```ts
let name: string | null = null;
if (name) console.log(name.length);
```

**Follow-up:** What happens if `strictNullChecks` is off?
**Answer:** TS allows **null/undefined assignments**, which can cause runtime errors.

---

### **23. Explain tuple types with rest elements.**

```ts
type StringNumberPair = [string, ...number[]];
const example: StringNumberPair = ["start", 1, 2, 3];
```

**Follow-up:** Why are rest tuples useful?
**Answer:** They allow **flexible-length tuples** with fixed initial types.

---

### **24. How does TypeScript handle function overloads?**

```ts
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: any, b: any) { return a + b; }
```

**Follow-up:** Why not rely solely on unions?
**Answer:** Overloads provide **distinct return types** for different argument combinations.

---

### **25. What is declaration merging and how is it used?**

```ts
interface User { name: string; }
interface User { age: number; }
const u: User = { name: "Rahil", age: 25 }; // ✅
```

**Follow-up:** Can types merge like interfaces?
**Answer:** No, only interfaces support **declaration merging**.

---

### **26. How do you enforce exhaustive type checks in union types?**

```ts
type Direction = "up" | "down";
function move(dir: Direction) {
  switch(dir) {
    case "up": return "UP";
    case "down": return "DOWN";
    default: const _exhaustive: never = dir; return _exhaustive;
  }
}
```

**Follow-up:** Why is `never` useful here?
**Answer:** Ensures **all union members are handled** at compile-time.

---

### **27. Explain how TypeScript handles async/await with types.**

```ts
async function fetch
```


User(): Promise<User> {
return { id: 1, name: "Rahil" };
}

````

**Follow-up:** How do you type API errors?  
**Answer:** Use `Promise<User | Error>` or `try/catch` with typed error handling.

---

### **28. What are template literal types?**
```ts
type EventName = `on${"Click" | "Hover"}`;
let e: EventName = "onClick"; // ✅
````

**Follow-up:** How can this improve **React prop typing**?
**Answer:** Restricts **event handler props** to valid names automatically.

---

### **29. How do you handle unknown third-party JSON in TypeScript?**

```ts
const data: unknown = JSON.parse("{}");
if (typeof data === "object" && data !== null) { /* safe */ }
```

**Follow-up:** Why not use `any`?
**Answer:** `any` disables type checking; `unknown` forces **type safety**.

---

### **30. Explain generics with default types.**

```ts
function identity<T = string>(arg: T): T { return arg; }
const str = identity(); // str inferred as string
```

**Follow-up:** Why are default generics useful?
**Answer:** Reduces **explicit type annotations** when a default is common.

---
Perfect! I’ll create a **comprehensive TypeScript interview guide** with all **50+ questions**, fully expanded with **answers, explanations, code examples, and follow-ups**. This will be formatted for **senior-level interview preparation**.

Here’s the plan:

---


### **31. Difference between type alias and abstract class**

**Answer:**

* Type alias: defines types for variables, objects, unions, intersections; no runtime presence.
* Abstract class: defines **shared structure and behavior** with actual JS output.

**Example:**

```ts
abstract class Shape {
  abstract area(): number;
}
type Point = { x: number; y: number };
```

**Follow-up:** Can you extend a type alias?
**Answer:** Use intersection: `type Point3D = Point & { z: number }`.

---

### **32. How does type inference work in functions?**

**Answer:** TypeScript infers the return type from **the function body** if not explicitly typed.

```ts
function sum(a: number, b: number) { return a + b; } // inferred: number
```

**Follow-up:** How to override inference?
**Answer:** Explicitly declare the return type: `function sum(a:number,b:number): number`.

---

### **33. Interface extension vs intersection type**

**Answer:**

* Interface: `interface A extends B {}`
* Intersection: `type C = A & B`

**Follow-up:** When to prefer intersection?
**Answer:** When combining **unions, primitives, or mapped types**, which interfaces cannot extend.

---

### **34. Explain symbol types**

**Answer:**

* `Symbol` creates **unique identifiers** at runtime.
* Useful for **private object keys** and **enums replacement**.

```ts
const id = Symbol("id");
const obj = { [id]: 123 };
```

**Follow-up:** Can TS type symbols safely?
**Answer:** Yes, `typeof id` gives the exact symbol type.

---

### **35. Typing recursive data structures**

```ts
interface TreeNode {
  value: number;
  children?: TreeNode[];
}
```

**Follow-up:** How to make it generic?

```ts
interface TreeNode<T> { value: T; children?: TreeNode<T>[]; }
```

---

### **36. Module augmentation**

**Answer:** Allows **adding new members to existing modules**.

```ts
declare module "express" { interface Request { user?: User; } }
```

**Follow-up:** Use case?
**Answer:** Extend third-party library types without editing source.

---

### **37. `typeof import()`**

```ts
const utils = await import("./utils");
type UtilsType = typeof utils;
```

**Follow-up:** Why is it useful?
**Answer:** For **dynamic imports and type-safe references** to modules.

---

### **38. Typing Promise rejection**

```ts
async function fetchData(): Promise<User> {
  if (Math.random() > 0.5) throw new Error("Fail");
  return { id: 1, name: "Rahil" };
}
```

**Follow-up:** How to type rejection?
**Answer:** TS does not type `throw`; handle via `try/catch` or `Result` wrapper type.

---

### **39. Conditional types with `infer`**

```ts
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
```

**Follow-up:** Example in real project?
**Answer:** Infer API response type from a generic fetch function.

---

### **40. Tuple functions**

```ts
type Callback = (a: number, b: string) => void;
```

**Follow-up:** How to get parameter types?

```ts
type Params = Parameters<Callback>; // [number, string]
```

---

### **41. Readonly arrays and tuples**

```ts
const nums: readonly number[] = [1,2,3];
```

**Follow-up:** Difference with normal arrays?
**Answer:** Cannot mutate; enforces immutability.

---

### **42. Typing React refs generically**

```ts
const inputRef = useRef<HTMLInputElement>(null);
```

**Follow-up:** Why not just `any`?
**Answer:** Maintains **type safety for DOM operations**.

---

### **43. Type-safe event emitters**

```ts
interface Events { click: MouseEvent; key: KeyboardEvent; }
function on<K extends keyof Events>(event: K, handler: (e: Events[K]) => void) {}
```

**Follow-up:** Benefit?
**Answer:** Guarantees **handler argument type matches event type**.

---

### **44. Middleware typing**

```ts
type Middleware<T> = (ctx: T, next: () => Promise<void>) => Promise<void>;
```

**Follow-up:** Use case?
**Answer:** Type-safe Koa/NestJS middleware pipelines.

---

### **45. JSX props typing**

```ts
interface ButtonProps { label: string; onClick?: () => void; }
```

**Follow-up:** How to type polymorphic components?

```ts
interface ButtonProps<T extends React.ElementType> { as?: T; children?: React.ReactNode; }
```

---

### **46. Partial nested objects**

```ts
type DeepPartial<T> = { [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K] };
```

**Follow-up:** Use case?
**Answer:** Updating deeply nested forms or API payloads.

---

### **47. Discriminated unions**

```ts
interface Circle { kind: "circle"; radius: number; }
interface Square { kind: "square"; side: number; }
type Shape = Circle | Square;
function area(s: Shape) {
  switch(s.kind) {
    case "circle": return Math.PI * s.radius**2;
    case "square": return s.side**2;
  }
}
```

**Follow-up:** Why prefer `kind` field?
**Answer:** Enables **compile-time exhaustive checks**.

---

### **48. `keyof typeof` combo**

```ts
const ROLES = { ADMIN: "admin", USER: "user" } as const;
type Role = keyof typeof ROLES; // "ADMIN" | "USER"
```

**Follow-up:** How does this enforce strict access?
**Answer:** Only allows keys in the object.

---

### **49. Type-safe builder pattern**

```ts
class UserBuilder {
  private user = {} as { name: string; age: number };
  setName(name: string) { this.user.name = name; return this; }
  setAge(age: number) { this.user.age = age; return this; }
  build() { return this.user; }
}
```

**Follow-up:** Why is TypeScript helpful here?
**Answer:** Ensures **all fields are typed**, preventing runtime errors.

---

### **50. Dynamic object keys safely**

```ts
type Options = Record<string, boolean>;
const opts: Options = { darkMode: true, beta: false };
```

**Follow-up:** How to type keys as literal union instead?

```ts
type Keys = "darkMode" | "beta";
const opts: Record<Keys, boolean> = { darkMode: true, beta: false };
```

---



